/*
 * This file is part of VLE, a framework for multi-modeling,
 * simulation and analysis of complex dynamical systems.
 * http://www.vle-project.org
 *
 * Copyright (c) 2016 Agilack
 */
#include "exploitation.h"

Exploitation::Exploitation()
{
    mAteliers.clear();
}

Exploitation::~Exploitation()
{
    while( ! mAteliers.isEmpty())
    {
        // Get the first list item
        Atelier *a = mAteliers.first();
        // Show current values (mainly for debug)
        a->dump();
        // Remove this item from list
        mAteliers.removeFirst();
        // Then, delete it
        delete a;
    }

    while( ! mRotations.isEmpty())
    {
        // Get the first list item
        Rotation *r = mRotations.last();
        // Remove this item from list
        mRotations.removeLast();
        // Then, delete it
        delete r;
    }
}

int Exploitation::atelierCount(void)
{
    return mAteliers.count();
}

Atelier *Exploitation::atelierCreate(const QString &name)
{
    // Sanity check
    if (name.isEmpty())
        return NULL;

    // Allocate a new Atelier
    Atelier *a = new Atelier();
    a->setName(name);
    // Then, insert it into this exploitation
    mAteliers.push_back(a);

    return a;
}

Atelier *Exploitation::atelierGet(int index)
{
    if (index > (atelierCount() - 1))
        return NULL;

    return mAteliers.at(index);
}

/**
 * @brief Get the number of available Rotations
 *
 * @return Number of Rotations into the Exploitation
 */
uint Exploitation::countRotation(void)
{
    return mRotations.count();
}

/**
 * @brief Create a new Rotation into the Exploitation
 *
 * @param name  String that define a name for this new Rotation
 * @param duration Number of years of the Rotation cycle
 * @return Pointer to the newly created Rotation
 */
Rotation *Exploitation::createRotation(const QString &name, ulong duration)
{
    if (name.isEmpty())
        return 0;

    // Create a new Rotation
    Rotation *newRotation = new Rotation(name, duration);

    // Insert it to the local cache
    mRotations.push_back(newRotation);

    return newRotation;
}

/**
 * @brief Get one Rotation
 *
 * @param index Index of the Rotation into the Exploitation
 * @return Pointer to the Rotation object
 */
Rotation *Exploitation::getRotation(uint index)
{
    if (index > (countRotation() - 1))
        return 0;

    return mRotations.at(index);
}

void Exploitation::insertAtelier(Atelier *atelier)
{
    if (atelier == NULL)
        return;

    mAteliers.push_back(atelier);
}

/**
 * @brief Remove one Rotation from Exploitation, identified by his index
 *
 * @param index Index of the Rotation to remove
 */
void Exploitation::removeRotation(uint index)
{
    if (index > (countRotation() - 1))
        return;

    // Take the specified Rotation from Exploitation
    Rotation *r = mRotations.takeAt(index);
    // Delete it
    delete r;
}
