/*
 * This file is part of VLE, a framework for multi-modeling,
 * simulation and analysis of complex dynamical systems.
 * http://www.vle-project.org
 *
 * Copyright (c) 2016 Agilack
 */
#include "exploitation.h"

/**
 * @brief Default constructor
 *
 */
Exploitation::Exploitation()
{
    mAteliers.clear();
}

/**
 * @brief Default destructor
 *
 */
Exploitation::~Exploitation()
{
    while( ! mAteliers.isEmpty())
    {
        // Get the first list item
        Atelier *a = mAteliers.first();
        // Remove this item from list
        mAteliers.removeFirst();
        // Then, delete it
        delete a;
    }

    while( ! mParameters.isEmpty())
    {
        // Get the first list item
        Parameter *p = mParameters.first();
        // Remove this item from list
        mParameters.removeFirst();
        // Then, delete it
        delete p;
    }

    while( ! mRotations.isEmpty())
    {
        // Get the first list item
        Rotation *r = mRotations.last();
        // Remove this item from list
        mRotations.removeLast();
        // Then, delete it
        delete r;
    }
}

/**
 * @brief Create a new Global Parameter and insert it into Exploitation
 *
 * @param name Name of the new parameter
 * @return Pointer to the newly created parameter
 */
Parameter *Exploitation::addParameter(const QString &name)
{
    Parameter *p = new Parameter(name);
    mParameters.push_back(p);
    return p;
}

/**
 * @brief Get the number of available Atelier(s)
 *
 * @return Number of atelier into the Exploitation
 */
uint Exploitation::countAtelier(void)
{
    return mAteliers.count();
}

/**
 * @brief Get the number of available Parameters
 *
 * @return Number of Parameters into the Exploitation
 */
uint Exploitation::countParameter(void)
{
    return mParameters.count();
}

/**
 * @brief Get the number of available Rotations
 *
 * @return Number of Rotations into the Exploitation
 */
uint Exploitation::countRotation(void)
{
    return mRotations.count();
}

/**
 * @brief Create a new Atelier into the Exploitation
 *
 * @param name String that define a name for this new Atelier
 * @return Pointer to the newly created Atelier (or NULL if fails)
 */
Atelier *Exploitation::createAtelier(const QString &name)
{
    // Sanity check
    if (name.isEmpty())
        return NULL;

    // Allocate a new Atelier
    Atelier *a = new Atelier();
    a->setName(name);
    // Then, insert it into this exploitation
    mAteliers.push_back(a);

    return a;
}

/**
 * @brief Create a new Rotation into the Exploitation
 *
 * @param name  String that define a name for this new Rotation
 * @param duration Number of years of the Rotation cycle
 * @return Pointer to the newly created Rotation
 */
Rotation *Exploitation::createRotation(const QString &name, ulong duration)
{
    if (name.isEmpty())
        return 0;

    // Create a new Rotation
    Rotation *newRotation = new Rotation(name, duration);

    // Insert it to the local cache
    mRotations.push_back(newRotation);

    return newRotation;
}

/**
 * @brief Get an Atelier, identified by his index
 *
 * @param index Index of the Atelier
 * @return Pointer to the requested Atelier (or NULL if not found)
 */
Atelier *Exploitation::getAtelier(int index)
{
    if (index > ((int)countAtelier() - 1))
        return NULL;

    return mAteliers.at(index);
}

/**
 * @brief Get a Parameter, identified by his index
 *
 * @param index Index of the Parameter
 * @return Pointer to the requested parameter (or NULL if not found)
 */
Parameter *Exploitation::getParameter(int index)
{
    if (index > (mParameters.count() - 1))
        return 0;

    return mParameters.at(index);
}

/**
 * @brief Get the value of a Parameter
 *
 * @param name Name of the Parameter
 * @return Current value of the parameter (0 if the requested name not exists)
 */
double Exploitation::getParameterValue(const QString &name)
{
    // Search the requested parameter
    for (int i = 0; i < mParameters.count(); ++i)
    {
        if (mParameters.at(i)->getName() == name)
            return mParameters.at(i)->getValue();
    }
    return 0;
}

/**
 * @brief Get one Rotation
 *
 * @param index Index of the Rotation into the Exploitation
 * @return Pointer to the Rotation object
 */
Rotation *Exploitation::getRotation(uint index)
{
    if (index > (countRotation() - 1))
        return 0;

    return mRotations.at(index);
}

/**
 * @brief Insert an already allocated Atelier into current Exploitation
 *
 * @param atelier Pointer to an existing Atelier
 */
void Exploitation::insertAtelier(Atelier *atelier)
{
    if (atelier == NULL)
        return;

    mAteliers.push_back(atelier);
}

/**
 * @brief Remove one Rotation from Exploitation, identified by a pointer on it
 *
 * @param rotation Pointer to an existing Rotation
 */
bool Exploitation::removeRotation(Rotation *rotation)
{
    bool result = false;

    for (int i = 0; i < mRotations.size(); ++i)
    {
        if (mRotations.at(i) == rotation)
        {
            // Remove item at current position from the list
            mRotations.removeAt(i);
            // Delete it
            delete rotation;
            // That's all folks
            result = true;
            break;
        }
    }
    return result;
}

/**
 * @brief Remove one Parameter from Exploitation, identified by a pointer on it
 *
 * @param param Pointer to the parameter to remove
 * @return Boolean value, true on success
 */
bool Exploitation::removeParameter(Parameter *param)
{
    int index = mParameters.indexOf(param);
    if (index < 0)
        return false;

    // Get a copy of this parameter
    Parameter *old = mParameters.at(index);
    // Remove the specified parameter ...
    mParameters.removeAt(index);
    // ... and delete it
    delete old;

    return true;
}

/**
 * @brief Remove one parameter from Exploitation, identified by his name
 *
 * @param name Name of the parameter to remove
 * @return Boolean value, true on success
 */
bool Exploitation::removeParameter(const QString &name)
{
    bool result = false;

    // Search the requested parameter
    for (int i = 0; i < mParameters.count(); ++i)
    {
        if (mParameters.at(i)->getName() == name)
        {
            // Get a copy of this parameter
            Parameter *old = mParameters.at(i);
            // Remove the specified parameter ...
            mParameters.removeAt(i);
            // ... and delete it
            delete old;

            result = true;
            break;
        }
    }
    return result;
}

/**
 * @brief Remove one Rotation from Exploitation, identified by his index
 *
 * @param index Index of the Rotation to remove
 */
bool Exploitation::removeRotation(uint index)
{
    if (index > (countRotation() - 1))
        return false;

    // Take the specified Rotation from Exploitation
    Rotation *r = mRotations.takeAt(index);
    // Delete it
    delete r;

    return true;
}

/**
 * @brief Set a new value for a global parameter
 *
 * @param name  Parameter name
 * @param value New value to set
 */
void Exploitation::setParameter(const QString &name, double value)
{
    Parameter *p = 0;

    // Search the requested parameter
    for (int i = 0; i < mParameters.count(); ++i)
    {
        if (mParameters.at(i)->getName() == name)
        {
            p = mParameters.at(i);
            break;
        }
    }

    // If the requested parameter does not exists yet, create it
    if (p == 0)
    {
        p = new Parameter(name);
        mParameters.push_back(p);
    }

    p->setValue(value);
}
